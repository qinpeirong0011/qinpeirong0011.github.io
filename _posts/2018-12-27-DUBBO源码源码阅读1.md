---
layout:     post
title:      DUBBO源码分析
subtitle:   内核SPI扩展实现
date:       2018-12-27
author:     qinpr
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - DUBBO
---

# 阅读dubbo代码的困惑
  在阅读dubbo源码的过程中，最初带给我最大的困惑就是在多实现的接口中，如何查找当前上下文中的接口实现。例如：
  ```
  LoadBalance loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);
  Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
  
  ```
  在dubbo源码中这样格式的代码大量存在，所以在学习dubbo代码前，一定要了解dubbo spi机制。这样对于dubbo的学习，会有事半功倍的效果。
# dubbo SPI简介
  dubbo采用微内核+插件的设计原则，即dubbo的所有的功能点都可以被用户自定义的插件覆盖。这种设计原是通过service provider interface(SPI)的方式实现的，就是厂商定义了服务标准，用户去实现。jdk中也实现了这点，至于dubbo为什么没有采用jdk标准的spi，而是自己重新实现了，官方给出的即解释是jdk会一次实例化所有的插件，即使有的插件用不到。dubbo的开发者认为这是一种资源浪费，dubbo想要的是只有在用到某种扩展插件的时候，再去实例化。<br/>
  <br/>
  例如，dubbo默认支持了ConsistentHashLoadBalance(一致性hash)、LeastActiveLoadBalance(最小活跃调用数)、RandomLoadBalance(按权重设置随机概率)、RoundRobinLoadBalance(按公约后的轮训设置权重比例)四种负载均衡策略。用户可以再此基础上扩展自己的负载均衡策略，并在consumer端指定自定义的负载策略。
  
# dubbo SPI文件声明  
 SPI扩展文件存储在以下三个路径
 ```
 META-INF/dubbo/internal/
 META-INF/dubbo/
 META-INF/services/
 ```
 dubbo支持的各种扩展实现都存储在第一个目录中了，但是dubbo在加载插件时仍然会扫描这三个目录。在每个spi文件中，格式定义为：扩展名=扩展实现类路径。如下：
 ```
 random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance
 roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance
 leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance
 consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance
 ```
 spi文件名称格式：接口的全路径名称，如下：
 ```
 com.alibaba.dubbo.rpc.cluster.LoadBalance
 ```
# LoadBalance
 下面以LoadBalance为实例，具体分析下dubbo在ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl().getMethodParameter(invocation.getMethodName(),Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE))的加载过程。<br/>
 看下com.alibaba.dubbo.rpc.cluster.LoadBalance这个接口声明，发现了两个注解@SPI、@Adaptive。<br/>
 1、@SPI: 指定接口的默认实现策略名称，这里LoadBalance默认的实现策略是RandomLoadBalance
 2、@Adaptive: 可以标记在SPI扩展类上，也可以标记在SPI接口的方法上。如果标记在扩展类上，SPI获取的实例是Adaptive+接口名称.class,如AdaptiveExtensionFactory、AdaptiveCompiler；如果标记在接口方法上，SPI对应的实例是动态代理类, 如LoadBalance$Adpative.class。
 
# E 
 
  
