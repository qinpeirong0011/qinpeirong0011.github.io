---
layout:     post
title:      DUBBO源码分析
subtitle:   内核SPI扩展实现
date:       2018-12-27
author:     qinpr
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - DUBBO
---

# 阅读dubbo代码的困惑
  在阅读dubbo源码的过程中，最初带给我最大的困惑就是在多实现的接口中，如何查找当前上下文中的接口实现。例如：
  ```
  Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
  Exporter<?> exporter = protocol.export(invoker);
  
  ```
  在dubbo源码中这样格式的代码大量存在，所以在学习dubbo代码前，一定要了解dubbo spi机制。这样对于dubbo的学习，会有事半功倍的效果。
# DUBBO SPI
  dubbo采用微内核+插件的设计原则，即dubbo的所有的功能点都可以被用户自定义的插件覆盖。这种设计原是通过service provider interface(SPI)的方式实现的，就是厂商定义了服务标准，用户去实现。jdk中也实现了这点，至于dubbo为什么没有采用jdk标准的spi，而是自己重新实现了，官方给出的即解释是jdk会一次实例化所有的插件，即使有的插件用不到。dubbo的开发者认为这是一种资源浪费，dubbo想要的是只有在用到某种扩展插件的时候，再去实例化。<br/>
  <br/>
  例如，dubbo默认支持了ConsistentHashLoadBalance(一致性hash)、LeastActiveLoadBalance(最小活跃调用数)、RandomLoadBalance(按权重设置随机概率)、RoundRobinLoadBalance(按公约后的轮训设置权重比例)四种负载均衡策略。用户可以再此基础上扩展自己的负载均衡策略，并在consumer端指定自定义的负载策略。
  
  
  
